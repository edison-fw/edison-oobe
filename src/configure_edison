#!/usr/bin/python3

# Copyright (c) 2014, Intel Corporation.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms and conditions of the GNU Lesser General Public License,
# version 2.1, as published by the Free Software Foundation.
#
# This program is distributed in the hope it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
# more details.
#

import os
import sys
from sys import stdout
import time
import termios
import fcntl
import subprocess
import signal
import hashlib
import argparse
import json
import re
from array import *
import configparser

WSREGEX = re.compile(r"\s+")
DESTINATION_PATH = "/tmp/"
STATE_DIR = '/var/lib/edison_config_tools'
HOST_AP_MODE_FILE = "/.start-in-host-ap-mode"
CURR_PACKAGE_PATH = ""

class text_colors:
  CYAN = '\033[96m'
  MAGENTA = '\033[95m'
  BLUE  = '\033[94m'
  YELLOW = '\033[93m'
  GREEN = '\033[92m'
  RED = '\033[91m'
  END = '\033[0m'

# Helpers
#######################################

def getch():
  fd = sys.stdin.fileno()

  oldterm = termios.tcgetattr(fd)
  newattr = termios.tcgetattr(fd)
  newattr[3] = newattr[3] & ~termios.ICANON & ~termios.ECHO
  termios.tcsetattr(fd, termios.TCSANOW, newattr)

  oldflags = fcntl.fcntl(fd, fcntl.F_GETFL)
  fcntl.fcntl(fd, fcntl.F_SETFL, oldflags | os.O_NONBLOCK)

  try:
    while 1:
      try:
        c = sys.stdin.read(1)
        break
      except IOError: pass
  finally:
    termios.tcsetattr(fd, termios.TCSAFLUSH, oldterm)
    fcntl.fcntl(fd, fcntl.F_SETFL, oldflags)
  return c

def getPassword(prompt):
  stdout.write(prompt)
  pw = ""

  while 1:
    c = getch()
    if c == '\r' or c == '\n':
      break
    if c == '\003':
      raise KeyboardInterrupt
    if c == '\x08' or c == '\x7f':
      if len(pw):
        pw = pw[:-1]
        stdout.write('\x08')
        stdout.write('\x20')
        stdout.write('\x08')
    else:
      pw = pw + c
      stdout.write("*")
  stdout.write('\r')
  stdout.write('\n')
  return pw

#failure code. needs to create an error log later.
def noooo(location):
  unacceptable_failure = "Strange Error... this shouldn't happen. Failure at %s. Let us know so we can patch this."
  print(unacceptable_failure % location)
  quit()

def verified(selection):
  verify = input("Is " + text_colors.MAGENTA + selection + text_colors.END + " correct? " + text_colors.YELLOW + "[Y or N]" + text_colors.END + ": ")
  if verify == "Y" or verify == "y":
    return 1
  elif verify == "N" or verify == "n":
    return 0
  else:
    while 1:
      verify = input("Please enter either " + text_colors.YELLOW + "[Y or N]" + text_colors.END + ": ")
      if verify == "Y" or verify == "y":
        return 1
      elif verify == "N" or verify == "n":
        return 0

def changeName(newName):
  if WSREGEX.search(newName):
      print("New name contains whitespaces. Ignoring")
      return
  _changeHostName(newName)
  _changeP2PSSID(newName)
  _changeAPSSID(newName)

def _changeHostName(newName):
  hostname_file = open('/etc/hostname','w')
  hostname_file.write(newName + "\n")
  hostname_file.close();
  subprocess.call("hostname -F /etc/hostname", shell=True)

def _changeAPSSID(newName):
  saveDefaultSSID()
  subprocess.call(["sed", "-i", "s/^ssid=.*/ssid=" + re.escape(newName) + "/", "/etc/hostapd.conf"])
  subprocess.call("systemctl restart mdns && sleep 2", shell=True)

def _changeP2PSSID(newName):
  subprocess.call(["sed", "-i", "s/^p2p_ssid_postfix=.*/p2p_ssid_postfix=" + re.escape(newName) + "/", "/etc/wpa_supplicant/p2p_supplicant.conf"])

def changePassword(newPass):
  if WSREGEX.search(newPass):
    print("New password contains whitespaces. Ignoring")
    return

  _changeRootPassword(newPass)
  if len(newPass) > 0:
    _changeAPPassword(newPass)

  if (not os.path.isfile(STATE_DIR + "/password-setup.done")):
    pass_done = open(STATE_DIR + "/password-setup.done", "w")
    pass_done.write("Indicates that password has been changed via oobe.\n")
    pass_done.close()
    print("First-time root password setup complete. Enabling SSH on WiFi interface.")
    subprocess.call("sed -i 's/^BindToDevice=/# BindToDevice=/g' /lib/systemd/system/sshd.socket ; sync ; systemctl daemon-reload; systemctl restart sshd.socket", shell=True)

def _changeRootPassword(newPass):
  echoSub = subprocess.Popen(["echo", "root:" + newPass], stdout=subprocess.PIPE)
  chpasswdSub = subprocess.Popen(["chpasswd"], stdin=echoSub.stdout, stdout=subprocess.PIPE)
  echoSub.stdout.close()  # Allow echoSub to receive a SIGPIPE if chpasswdSub exits.
  chpasswdSub.communicate()[0]

def _changeAPPassword(newPass):
  subprocess.call(["sed", "-i", "s/^wpa_passphrase=.*/wpa_passphrase=" + re.escape(newPass) + "/", "/etc/hostapd.conf"])

def getNetworkIdentity():
  return input("Please enter the network username: ")

def getNetworkPassword():
  pw = ''
  while len(pw) == 0:
    pw = getPassword("What is the network password?: ")
  return pw

def reset(stage):
  subprocess.call("clear", shell=True)
  print(text_colors.CYAN + "\nConfigure Edison: " + stage + "\n" + text_colors.END)


# Main Functions
#######################################

def setEdisonHostname():
  while 1:
    name = input("Give this Edison a unique name.\nThis will be used for the access point SSID and mDNS address.\nMake it at least five characters long (leave empty to skip): ")
    if (WSREGEX.search(name)):
      print("")
      print('Hostname must not contain whitespaces. Please try again.')
      print("")
    elif (len(name) == 0):
      print("Skipping name change...")
      break
    elif (len(name) > 4):
      if verified(name):
        print("")
        break
      else:
        print("")
    else:
      print("")
      print('\"' + name + '\" is too short. Please try again.')
      print("")

  if len(name) > 0:
      changeName(name)

def setEdisonPassword():
   while 1:
     password = getPassword("Enter a new password (leave empty to abort)\nThis will be used to connect to the access point and login to the device.\nPassword: \t")
     if (password == getPassword("Please enter the password again: \t")):
         if (WSREGEX.search(password)):
             print("")
             print('The device password must not contain whitespaces. Please try again.')
             print("")
         elif len(password) == 0:
             print("Skipping password change.")
             return
         elif len(password) < 8 or len(password) > 63:
             print("")
             print("The device password must be between 8 and 63 characters long. Please try again.")
             print("")
         else:
             break
     else:
       print("")
       print("The passwords do not match. Please try again.")
       print("")

   changePassword(password)
   print("The device password has been changed.\n")

def decideToConnect():
  while 1:
    verify = input("Do you want to set up wifi? " + text_colors.YELLOW + "[Y or N]" + text_colors.END + ": ")
    if verify == "y" or verify == "Y":
      return 1
    elif verify == "n" or verify == "N":
      return 0
    else:
      print("I need Y or N as a reply.")

WPAPSK_REGEX=re.compile(r'\[WPA[2]?-PSK-.+\]')
WPAEAP_REGEX=re.compile(r'\[WPA[2]?-EAP-.+\]')
WEP_REGEX=re.compile(r'\[WEP.*\]')

def scanForNetworks():
  stdout.write("Starting scan\r")
  stdout.flush()
  os.popen("systemctl stop hostapd && sleep 2 && systemctl start wpa_supplicant")
  r = range(10,0,-1)
  for i in r:
    stdout.write("Scanning: %s seconds left \r" % i)
    stdout.flush()
    if i == 6:
      os.popen("wpa_cli scan")
    time.sleep(1)

  data = os.popen("wpa_cli scan_results").read().split("\n")

  print("\n")
  network_map = {}
  ssid_keys = []

  while (len(data)):
    line = data.pop().split("\t")
    if (len(line) == 5):
      ssid = line.pop()
      if ssid not in ssid_keys and not ssid == "" and "\\x00" not in ssid:
        tokens = line.pop()
        if WPAPSK_REGEX.search(tokens):
          network_map[ssid] = "WPA-PSK"
        elif WPAEAP_REGEX.search(tokens):
          network_map[ssid] = "WPA-EAP"
        elif WEP_REGEX.search(tokens):
          network_map[ssid] = "WEP"
        else:
          network_map[ssid] = "OPEN"

        ssid_keys.append(ssid)

  network_file = open(STATE_DIR + "/networks.txt", "w")
  network_file.write("{\n")
  for i in range(0, len(ssid_keys)):
    network_file.write('\t"' + ssid_keys[i] + '": "' + network_map[ssid_keys[i]])
    if i == len(ssid_keys)-1:
        network_file.write('"\n')
    else:
        network_file.write('",\n')
  network_file.write("}\n")
  network_file.close()

  return (ssid_keys, network_map)

def selectNetwork(ssid_keys):
  i = 2
  print("0 :\tRescan for networks")
  print("1 :\tExit WiFi Setup")
  print("2 :\tManually input a hidden SSID")
  for ssid in ssid_keys:
    i = i + 1
    print(i, ":\t", ssid)

  print("")
  choice = -1
  while 1:
    try:
      if i == 2:
        choice = int(input("\nEnter 0 to rescan for networks.\nEnter 1 to exit.\nEnter 2 to input a hidden network SSID: "))
      elif i == 3:
        choice = int(input("\nEnter 0 to rescan for networks.\nEnter 1 to exit.\nEnter 2 to input a hidden network SSID.\nEnter 3 to choose %s: " % ssid_keys[0]))
      else:
        choice = int(input("\nEnter 0 to rescan for networks.\nEnter 1 to exit.\nEnter 2 to input a hidden network SSID.\nEnter a number between 3 to %s to choose one of the listed network SSIDs: " % i))
    except TypeError:
      choice = -1
    except ValueError:
      choice = -1

    if choice == 0:
      break
    elif choice == 1:
      sys.exit(0)
    elif choice == 2:
      break
    elif choice > 2 and choice <= i and verified(ssid_keys[choice-3]):
      break
  return choice

def configureHiddenNetwork(ssid):
  print('''
    0: OPEN
    1: WEP
    2: WPA-Personal(PSK)
    3: WPA-Enterprise (EAP)
  ''')
  while 1:
    try:
      security = int(input("Select the type of security [0 to 3]: "))
    except TypeError:
      security = -1
    except ValueError:
      security = -1

    if security == 0:
      return wpa_templates.OPEN % (ssid, "scan_ssid=1")
    elif security == 1:
      password = ''
      while len(password) != 5 and len(password) != 13:
        print("Password must be either 5 or 13 characters.")
        password = getNetworkPassword()
      return wpa_templates.WEP % (ssid, "scan_ssid=1", password)
    elif security == 2:
      password = ''
      while len(password) < 8 or len(password) > 63:
        print("Password must be between 8 and 63 characters.")
        password = getNetworkPassword()
      return wpa_templates.WPAPSK % (ssid, "scan_ssid=1", password)
    elif security == 3:
      identity = getNetworkIdentity()
      password = getNetworkPassword()
      return wpa_templates.WPAEAP % (ssid, "scan_ssid=1", identity, password)
    else:
      print("Invalid input.")
  return network_template_open % ssid

def configureNetwork(choice,ssid_keys,network_map):
  ssid = ssid_keys[choice-3]
  if network_map[ssid] == "OPEN":
    return wpa_templates.OPEN % (ssid, "")
  elif network_map[ssid] == "WEP":
    password = ''
    while len(password) != 5 and len(password) != 13:
        print("Password must be either 5 or 13 characters.")
        password = getNetworkPassword()
    return wpa_templates.WEP % (ssid, "", password)
  elif network_map[ssid] == "WPA-PSK":
    password = ''
    while len(password) < 8 or len(password) > 63:
        print("Password must be between 8 and 63 characters.")
        password = getNetworkPassword()
    return wpa_templates.WPAPSK % (ssid, "", password)
  elif network_map[ssid] == "WPA-EAP":
    identity = getNetworkIdentity()
    password = getNetworkPassword()
    return wpa_templates.WPAEAP % (ssid, "", identity, password)
  else:
    print(noooo("the last line of startNetworkConfig"))

def configureNetworkAP(changewifi):
  protocol = changewifi[0]
  ssid = changewifi[1]
  if protocol == "OPEN":
    return wpa_templates.OPEN % (ssid, "scan_ssid=1")
  elif protocol == "WEP":
    password = changewifi[2]
    if len(password) != 5 and len(password) != 13:
        print("Password must be either 5 or 13 characters.")
        return None
    return wpa_templates.WEP % (ssid, "scan_ssid=1", password)
  elif protocol == "WPA-PSK":
    password = changewifi[2]
    if len(password) < 8 or len(password) > 63:
        print("Password must be between 8 and 63 characters.")
        return None
    return wpa_templates.WPAPSK % (ssid, "scan_ssid=1", password)
  elif protocol == "WPA-EAP":
    if len(changewifi) != 4:
      print("Both Identify and Password must be provided. Unable to proceed")
      return
    identity = changewifi[2]
    password = changewifi[3]
    return wpa_templates.WPAEAP % (ssid, "scan_ssid=1", identity, password)
  else:
    print(noooo("the last line of startNetworkConfig"))

def setNetwork(network_conf, ssid):
    if not os.path.isfile('/etc/wpa_supplicant/wpa_supplicant.conf.original'):
        subprocess.call("cp /etc/wpa_supplicant/wpa_supplicant.conf /etc/wpa_supplicant/wpa_supplicant.conf.original", shell=True)

    wpa_supplicant = open('/etc/wpa_supplicant/wpa_supplicant.conf','a') #Will not take care of duplicates at the moment.
    wpa_supplicant.write(network_conf)
    wpa_supplicant.close();

    print("Initiating connection to " + ssid + ". Please wait...")

    try:
        if int(subprocess.check_output("systemctl status wpa_supplicant | grep 'active (running)' | wc -l", shell=True)) == 0:
          subprocess.call("systemctl stop hostapd &> /dev/null", shell=True)
          subprocess.call("systemctl start wpa_supplicant &> /dev/null", shell=True)
          time.sleep(10)
        else:
          subprocess.call("wpa_cli reconfigure &> /dev/null && sleep 2", shell=True)

        network_count = int(subprocess.check_output('wpa_cli list_networks | wc -l', shell=True))
        subprocess.call("wpa_cli select_network " + str(network_count - 2 - 1) + " &> /dev/null", shell=True)
        time.sleep(5)

        ifarray = subprocess.check_output("wpa_cli ifname", shell=True).split()
        subprocess.call("udhcpc -i " + ifarray[len(ifarray)-1] + " -n &> /dev/null", shell=True)
    except Exception as e:
        print(e)
        print("Sorry. Could not get an IP address.")
    else:
        print("Attempting to enable network access, please check 'wpa_cli status' after a minute to confirm.")

def checkNetwork():
  i = 60
  while 1:
    waiting = "Connecting: %s seconds left         \r" % i
    stdout.write(waiting)
    stdout.flush()
    time.sleep(1)
    address = os.popen("ifconfig | grep -A1 'wlan0' | grep 'inet'| awk -F' ' '{ print $2 }' | awk -F':' '{ print $2 }'").read().rstrip()
    if not address == "":
      print("Done. Please connect your laptop or PC to the same network as this device and go to " + \
        text_colors.CYAN + "http://" + address + text_colors.END + " or " + text_colors.CYAN + \
        "http://" + subprocess.check_output('hostname').strip() + ".local" + text_colors.END + \
        " in your browser.")
      break
    if i == 0:
      print("Not connected. Something went wrong.")
      break
    i = i-1

def connectNetwork():
  network_conf = ""
  ssid = ""

  while 1:
    reset("WiFi Connection")
    (ssid_keys, network_map) = scanForNetworks()
    choice = selectNetwork(ssid_keys)

    #choice is validated within selectNetwork.
    if choice == 2:
      while 1:
          ssid = input("Please enter the hidden network SSID: ")
          if verified(ssid):
              break
      network_conf = configureHiddenNetwork(ssid)
      break
    elif choice:
      network_conf = configureNetwork(choice, ssid_keys,network_map)
      ssid = ssid_keys[choice-3]
      break

  #print network_conf
  setNetwork(network_conf, ssid)
  checkNetwork()
  disableOneTimeSetup(True)

def showWiFiIP():
    ipstr = ''
    try:
        ipstr = subprocess.check_output('ifconfig wlan0 | grep \'inet addr:\'', shell=True)
    except subprocess.CalledProcessError:
        print("No IP address found. Device not connected?", file=sys.stderr)
        return "none"
    except Exception as inst:
        print(type(inst), file=sys.stderr)
        print(inst, file=sys.stderr)
        return "none"

    ipstr = str(ipstr, 'utf-8')
    startIdx = ipstr.find('inet addr:')
    if (startIdx == -1):
         return "none"
    ipstr = ipstr[ipstr.find('inet addr:')+10:].split()[0]
    return ipstr

def showWiFiMode():
    modestr = ''
    try:
        modestr = subprocess.check_output('connmanctl technologies', shell=True)
    except subprocess.CalledProcessError:
        print("No interface found.", file=sys.stderr)
        return "none"
    except Exception as inst:
        print(type(inst), file=sys.stderr)
        print(inst, file=sys.stderr)
        return "none"

    modestr = str(modestr, 'utf-8')
    modestr = "[Wifi]" + modestr.split('/net/connman/technology/wifi')[1].split('/net/connman/technology')[0].replace(' ','')
    Section = configparser.ConfigParser()
    Section.read_string(modestr)
    if Section['Wifi']['Connected'] == 'True':
        return "Managed"
    if Section['Wifi']['Tethering'] == 'True':
        return "Master"
    return "none"

def getCurrentFirmwareInfo():
    f = open('/etc/version','r')
    ver_str = f.readline()
    f.close()
    return ("edison-" + ver_str.split('-')[0], ver_str.split('-')[1].splitlines()[0])

def isRestartWithAPSet():
    try:
        ret_value = subprocess.call("mkdir -p /update", shell=True)
        if ret_value != 0:
            print("Could not create destination folder.")
            return False
    except Exception as inst:
        print("Could not create destination folder.")
        print(type(inst), file=sys.stderr)
        print(inst, file=sys.stderr)
        return False

    try:
        ret_value = subprocess.call("losetup -o 8192 /dev/loop0 /dev/disk/by-partlabel/update", shell=True)
        if ret_value != 0:
            print("Could not setup loop device")
            return False
    except Exception as inst:
        print("Could not setup loop device")
        print(type(inst), file=sys.stderr)
        print(inst, file=sys.stderr)
        return False

    try:
        ret_value = subprocess.call("mount /dev/loop0 /update", shell=True)
        if ret_value != 0:
            print("Could not perform mount operation.")
            return False
    except Exception as inst:
        print("Could not perform mount operation.")
        print(type(inst), file=sys.stderr)
        print(inst, file=sys.stderr)
        return False

    if os.path.isfile("/update" + HOST_AP_MODE_FILE):
        ap_mode = True
    else:
        ap_mode = False
    try:
        ret_value = subprocess.call("umount /update", shell=True)
        if ret_value != 0:
            print("Could not perform umount operation.")
            return False
    except Exception as inst:
        print("Could not perform umount operation.")
        print(type(inst), file=sys.stderr)
        print(inst, file=sys.stderr)
        return False
    try:
        ret_value = subprocess.call("rmdir /update", shell=True)
        if ret_value != 0:
            print("Could not delete destination folder.")
            return False
    except Exception as inst:
        print("Could not delete destination folder.")
        print(type(inst), file=sys.stderr)
        print(inst, file=sys.stderr)
        return False

    return ap_mode

def full():
  reset("Device Password")
  setEdisonPassword()
  reset("Device Name")
  setEdisonHostname()
  if decideToConnect():
    connectNetwork()
  else:
    print("Done.\n")

def getSSID():
    return subprocess.check_output("grep -o '^ssid=.*' /etc/hostapd.conf | awk -F'=' '{print $2}'", shell=True).strip()

def saveDefaultSSID():
    if not os.path.isfile(STATE_DIR + "/default-ssid.txt"):
        curr_ssid = getSSID()
        default_ssid_file = open(STATE_DIR + "/default-ssid.txt", "w")
        default_ssid_file.write(curr_ssid + "\n")
        default_ssid_file.close()

def getDefaultSSID():
    saveDefaultSSID()
    default_ssid_file = open(STATE_DIR + "/default-ssid.txt", "r")
    curr_ssid = default_ssid_file.readline()
    default_ssid_file.close()
    return curr_ssid.strip()

def enableOneTimeSetup(persist):
    subprocess.call("systemctl restart blink-led", shell=True)

    hostname = subprocess.check_output('hostname').strip()

    print("Scanning and saving WiFi networks...")
    scanForNetworks()

    subprocess.call("systemctl stop wpa_supplicant", shell=True)

    print("Restarting WiFi access point. Please wait...")
    print("")

    if persist:
        subprocess.call("systemctl disable wpa_supplicant &> /dev/null", shell=True)
        subprocess.call("systemctl enable hostapd &> /dev/null", shell=True)
        subprocess.call("systemctl enable blink-led &> /dev/null", shell=True)

    if int(subprocess.check_output("systemctl status hostapd | grep 'active (running)' | wc -l", shell=True)) == 0:
        subprocess.call("systemctl start hostapd &> /dev/null", shell=True)

    myssid = getSSID()

    print("From your PC or laptop, connect to the", "'" + myssid + "' network ")
    print("and visit",  "'" + hostname + ".local' in the browser")

def disableOneTimeSetup(persist):
    subprocess.call("systemctl stop blink-led &> /dev/null", shell=True)
    subprocess.call("systemctl stop hostapd &> /dev/null", shell=True)

    try:
        os.remove(STATE_DIR + "/networks.txt")
    except Exception as inst:
        pass

    if persist:
        subprocess.call("systemctl enable wpa_supplicant &> /dev/null", shell=True)
        subprocess.call("systemctl disable hostapd &> /dev/null", shell=True)
        subprocess.call("systemctl disable blink-led &> /dev/null", shell=True)

    if int(subprocess.check_output("systemctl status wpa_supplicant | grep 'active (running)' | wc -l", shell=True)) == 0:
        subprocess.call("systemctl start wpa_supplicant &> /dev/null", shell=True)

def toggleOneTimeSetup(persist):
    if showWiFiMode() == "Master":
        disableOneTimeSetup(persist)
    else:
        enableOneTimeSetup(persist)

def showNames():
    hostname = subprocess.check_output('hostname', shell=True).strip()
    ssid = getSSID()
    default_ssid = getDefaultSSID()
    print('{"hostname": "' + str(hostname, 'utf-8') + '", "ssid": "' + str(ssid, 'utf-8') + '", "default_ssid": "' + default_ssid + '"}')

def main():

    global CURR_PACKAGE_PATH

    parser = argparse.ArgumentParser(prog='configure_edison')

    parser.add_argument('--restartWithAP', dest='restartwithap', help=argparse.SUPPRESS, action='store_true', default=False)
    parser.add_argument('--persist', dest='persist', help=argparse.SUPPRESS, action='store_true', default=False)

    root_group = parser.add_mutually_exclusive_group()

    group_interactive = root_group.add_mutually_exclusive_group()
    group_interactive.add_argument('--setup', dest='setup', help='Goes through changing the device name, password, and wifi options', action='store_true', default=False)
    group_interactive.add_argument('--name', dest='name', help='Changes the device name', action='store_true', default=False)
    group_interactive.add_argument('--password', dest='password', help='Changes the device password', action='store_true', default=False)
    group_interactive.add_argument('--wifi', dest='wifi', help='Changes the wifi options', action='store_true', default=False)

    group_non_interactive = root_group.add_mutually_exclusive_group()
    group_non_interactive.add_argument('--isRestartWithAPSet', dest='isrestartwithapset', help=argparse.SUPPRESS, action='store_true', default=False)
    group_non_interactive.add_argument('--showWiFiIP', dest='showwifiip', help='IP address associated with the wireless interface', action='store_true', default=False)
    group_non_interactive.add_argument('--showWiFiMode', dest='showwifimode', help='Show current mode for the wireless interface', action='store_true', default=False)
    group_non_interactive.add_argument('--disableOneTimeSetup', dest='disableonetimesetup', help='Disable one-time setup with WiFi access point and enable WiFi client mode \
                                       Append --persist to retain this setting after reboot', action='store_true', default=False)
    group_non_interactive.add_argument('--enableOneTimeSetup', dest='enableonetimesetup', help='Enable one-time setup with WiFi access point and disable WiFi client mode. \
                                        Append --persist to retain this setting after reboot', action='store_true', default=False)
    group_non_interactive.add_argument('--toggleOneTimeSetup', dest='toggleonetimesetup', help='Switch between one-time setup with WiFi access point and WiFi client mode, and visa-versa. \
                                       Append --persist to retain this setting after reboot', action='store_true', default=False)
    group_non_interactive.add_argument('--changePassword', metavar='password', dest='changepassword', const='', help=argparse.SUPPRESS, nargs='?')
    group_non_interactive.add_argument('--changeName', metavar='name', dest='changename', help=argparse.SUPPRESS, nargs=1)
    group_non_interactive.add_argument('--changeWiFi', metavar='securityType SSID [Identity | password]', dest='changewifi', help=argparse.SUPPRESS, nargs='+')
    group_non_interactive.add_argument('--showNames', dest='shownames', help='Show device name and SSID', action='store_true', default=False)

    if len(sys.argv)==1:
        parser.print_help()
        sys.exit(1)

    args = parser.parse_args()

    if args.name:
        reset("Device Name")
        setEdisonHostname()

    if args.password:
        reset("Device Password")
        setEdisonPassword()

    if args.wifi:
        connectNetwork()
        if not os.path.isfile(STATE_DIR + "/password-setup.done"):
            print("Warning: SSH is not yet enabled on the wireless interface. To enable SSH access to this device via wireless run configure_edison --password first.")

    if args.setup:
        full()

    if args.shownames:
        showNames()

    if args.isrestartwithapset:
        print(isRestartWithAPSet())

    if args.changepassword != None:
        changePassword(args.changepassword)

    if args.changename != None:
        changeName(args.changename[0])

    if args.showwifiip:
        print(showWiFiIP())

    if args.showwifimode:
        print(showWiFiMode())

    if args.enableonetimesetup:
        enableOneTimeSetup(args.persist)

    if args.disableonetimesetup:
        disableOneTimeSetup(args.persist)

    if args.toggleonetimesetup:
        toggleOneTimeSetup(args.persist)

    if args.changewifi != None:
        network_conf = configureNetworkAP(args.changewifi)
        if network_conf != None:
            setNetwork(network_conf, args.changewifi[1])

    #print 'restartwithap = ',args.restartwithap
    #print 'persist = ',args.persist
    #print 'setup = ',args.setup
    #print 'name = ',args.name
    #print 'password = ',args.password
    #print 'wifi = ',args.wifi

    #print 'showwifiip = ',args.showwifiip
    #print 'disableonetimesetup = ',args.disableonetimesetup
    #print 'enableonetimesetup = ',args.enableonetimesetup
    #print 'changepassword = ',args.changepassword

    #print 'changename = ',args.changename

if __name__ == "__main__":
      main()
