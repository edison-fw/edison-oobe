#!/usr/bin/python3

# Copyright (c) 2014, Intel Corporation.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms and conditions of the GNU Lesser General Public License,
# version 2.1, as published by the Free Software Foundation.
#
# This program is distributed in the hope it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
# more details.
#

import os
import sys
from sys import stdout
import time
import termios
import fcntl
import subprocess
import signal
import hashlib
import argparse
import json
import re
from array import *
import configparser
from bottle import Bottle, route, run, debug, template, request, static_file, error, redirect
import datetime
from datetime import timedelta

WSREGEX = re.compile(r"\s+")
DESTINATION_PATH = "/tmp/"
STATE_DIR = '/var/lib/edison_config_tools'
HOST_AP_MODE_FILE = "/.start-in-host-ap-mode"
CURR_PACKAGE_PATH = ""
CONNMAN_SETTINGS = "/var/lib/connman/settings"
CONNMAN_SERVICES = "/var/lib/connman/wifi.config"

# Types
#######################################
class classHostName:
    Old = ""
    New = ""
    Valid = 0
    Changed = 0
    Checked = ""
    Tooltip = ""

class classWired:
    Old = ""
    New = ""
    Type = ""
    Mode = ""
    IP = ""
    Valid = 0
    Changed = 0
    Checked = ""
    Tooltip = ""

class classSettings:
    HostName = classHostName()
    Wired = classWired()

class text_colors:
  CYAN = '\033[96m'
  MAGENTA = '\033[95m'
  BLUE  = '\033[94m'
  YELLOW = '\033[93m'
  GREEN = '\033[92m'
  RED = '\033[91m'
  END = '\033[0m'

# Helpers
#######################################
def getch():
  fd = sys.stdin.fileno()

  oldterm = termios.tcgetattr(fd)
  newattr = termios.tcgetattr(fd)
  newattr[3] = newattr[3] & ~termios.ICANON & ~termios.ECHO
  termios.tcsetattr(fd, termios.TCSANOW, newattr)

  oldflags = fcntl.fcntl(fd, fcntl.F_GETFL)
  fcntl.fcntl(fd, fcntl.F_SETFL, oldflags | os.O_NONBLOCK)

  try:
    while 1:
      try:
        c = sys.stdin.read(1)
        break
      except IOError: pass
  finally:
    termios.tcsetattr(fd, termios.TCSAFLUSH, oldterm)
    fcntl.fcntl(fd, fcntl.F_SETFL, oldflags)
  return c

def getPassword(prompt):
  stdout.write(prompt)
  pw = ""

  while 1:
    c = getch()
    if c == '\r' or c == '\n':
      break
    if c == '\003':
      raise KeyboardInterrupt
    if c == '\x08' or c == '\x7f':
      if len(pw):
        pw = pw[:-1]
        stdout.write('\x08')
        stdout.write('\x20')
        stdout.write('\x08')
    else:
      pw = pw + c
      stdout.write("*")
  stdout.write('\r')
  stdout.write('\n')
  return pw

#failure code. needs to create an error log later.
def noooo(location):
  unacceptable_failure = "Strange Error... this shouldn't happen. Failure at %s. Let us know so we can patch this."
  print(unacceptable_failure % location)
  quit()

def verified(selection):
  verify = input("Is " + text_colors.MAGENTA + selection + text_colors.END + " correct? " + text_colors.YELLOW + "[Y or N]" + text_colors.END + ": ")
  if verify == "Y" or verify == "y":
    return 1
  elif verify == "N" or verify == "n":
    return 0
  else:
    while 1:
      verify = input("Please enter either " + text_colors.YELLOW + "[Y or N]" + text_colors.END + ": ")
      if verify == "Y" or verify == "y":
        return 1
      elif verify == "N" or verify == "n":
        return 0

def _checkName(newName):
    length = len(newName)
    if length < 1 or length > 63:
        return -1
    if newName[0] == '-' or newName[length - 1] == '-':
        return -2
    for i in range(length):
        if not newName[i].isalnum() and newName[i] != '-':
            return -3
    return 0

def changeName(newName):
    if _checkName(newName) < 0:
        print("Invalid new name. Ignoring")
        return
    _changeHostName(newName)
    _changeP2PSSID(newName)
    _changeAPSSID(newName)

def _changeHostName(newName):
  hostname_file = open('/etc/hostname','w')
  hostname_file.write(newName + "\n")
  hostname_file.close();
  subprocess.call("hostname -F /etc/hostname", shell=True)

def _getDefaultSSID():
    data = os.popen("cat /sys/class/net/wlan0/address | tr '[:lower:]' '[:upper:]'").read()
    APSSID = "EDISON-" + data[12:14] +"-" + data[15:17]
    return APSSID

def _getAPSSID():
    ConnmanSettings = configparser.ConfigParser()
    ConnmanSettings.optionxform=str
    ConnmanSettings.read(CONNMAN_SETTINGS)
    APSSID = ConnmanSettings.get('WiFi', 'Tethering.Identifier', fallback='')

    if APSSID == "":
        passphrase = os.popen("cat /factory/serial_number").read()
        ConnmanSettings['WiFi']['Tethering.Identifier'] = _getDefaultSSID()
        ConnmanSettings['WiFi']['Tethering.Passphrase'] = passphrase
        with open(CONNMAN_SETTINGS, 'w') as configfile:
            ConnmanSettings.write(configfile)
    return(APSSID)

def _changeAPSSID(newName):
    ConnmanSettings = configparser.ConfigParser()
    ConnmanSettings.optionxform=str
    ConnmanSettings.read(CONNMAN_SETTINGS)
    ConnmanSettings['WiFi']['Tethering.Identifier'] = newName
    with open(CONNMAN_SETTINGS, 'w') as configfile:
        ConnmanSettings.write(configfile)

def _changeAPPassword(newPass):
    ConnmanSettings = configparser.ConfigParser()
    ConnmanSettings.optionxform=str
    ConnmanSettings.read(CONNMAN_SETTINGS)
    ConnmanSettings['WiFi']['Tethering.Passphrase'] = newPass
    with open(CONNMAN_SETTINGS, 'w') as configfile:
        ConnmanSettings.write(configfile)

def _getWiFiMode():
    modestr = ''
    try:
        modestr = subprocess.check_output('connmanctl technologies', shell=True)
    except subprocess.CalledProcessError:
        return "Err"
    except Exception as inst:
        return "Err"

    modestr = str(modestr, 'utf-8')
    modestr = "[Wifi]" + modestr.split('/net/connman/technology/wifi')[1].split('/net/connman/technology')[0].replace(' ','')
    Section = configparser.ConfigParser()
    Section.optionxform=str
    Section.read_string(modestr)
    if Section['Wifi']['Connected'] == 'True':
        return "Connected"
    if Section['Wifi']['Tethering'] == 'True':
        return "AP"
    if Section['Wifi']['Powered'] == 'True':
        return "Powered"
    return "Off"

def _getWiredMode():
    modestr = ''
    try:
        modestr = subprocess.check_output('connmanctl technologies', shell=True)
    except subprocess.CalledProcessError:
        return "Err"
    except Exception as inst:
        return "Err"

    modestr = str(modestr, 'utf-8')
    if modestr.find("ethernet") == -1:
        return "None"
    modestr = "[Wired]" + modestr.split('/net/connman/technology/ethernet')[1].split('/net/connman/technology')[0].replace(' ','')
    Section = configparser.ConfigParser()
    Section.optionxform=str
    Section.read_string(modestr)
    if Section['Wired']['Connected'] == 'True':
        return "Connected"
    if Section['Wired']['Powered'] == 'True':
        return "Powered"
    return "Off"

def _getBTMode():
    modestr = ''
    try:
        modestr = subprocess.check_output('connmanctl technologies', shell=True)
    except subprocess.CalledProcessError:
        return "Err"
    except Exception as inst:
        return "Err"

    modestr = str(modestr, 'utf-8')
    if modestr.find("bluetooth") == -1:
        return "None"
    modestr = "[Bluetooth]" + modestr.split('/net/connman/technology/bluetooth')[1].split('/net/connman/technology')[0].replace(' ','')
    Section = configparser.ConfigParser()
    Section.optionxform=str
    Section.read_string(modestr)
    if Section['Bluetooth']['Connected'] == 'True':
        return "Connected"
    if Section['Bluetooth']['Powered'] == 'True':
        return "Powered"
    return "Off"

def _getGadgetMode():
    modestr = ''
    modestr = subprocess.run('lsusb', shell=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    modestr = str(modestr.stderr, 'utf-8')
    gadget = modestr.find("unable to initialize libusb")
    if gadget == -1:
        return "None"
    modestr = ''
    try:
        modestr = subprocess.check_output('connmanctl technologies', shell=True)
    except subprocess.CalledProcessError:
        return "Err"
    except Exception as inst:
        return "Err"

    modestr = str(modestr, 'utf-8')
    if modestr.find("gadget") == -1:
        return "Err"
    modestr = "[Wired]" + modestr.split('/net/connman/technology/gadget')[1].split('/net/connman/technology')[0].replace(' ','')
    Section = configparser.ConfigParser()
    Section.optionxform=str
    Section.read_string(modestr)
    if Section['Wired']['Connected'] == 'True':
        return "Connected"
    if Section['Wired']['Powered'] == 'True':
        return "Powered"
    return "Off"

def _setWiFiMode(Mode):
    CurrentMode = _getWiFiMode()
    if CurrentMode == 'Err':
        return
    if Mode == 'Off':
        if CurrentMode != 'Off':
            subprocess.check_output("connmanctl disable wifi", shell=True)
    elif Mode == 'Powered':
        if CurrentMode == 'Off':
            subprocess.check_output("connmanctl enable wifi", shell=True)
        if CurrentMode == 'AP':
            subprocess.check_output("connmanctl tether wifi off", shell=True)
    elif Mode == 'AP':
        if CurrentMode == 'Off':
            subprocess.check_output("connmanctl enable wifi && connmanctl tether wifi on", shell=True)
    time.sleep(1)
    return

def _changeP2PSSID(newName):
  subprocess.call(["sed", "-i", "s/^p2p_ssid_postfix=.*/p2p_ssid_postfix=" + re.escape(newName) + "/", "/etc/wpa_supplicant/p2p_supplicant.conf"])

def changePassword(newPass):
  if WSREGEX.search(newPass):
    print("New password contains whitespaces. Ignoring")
    return

  _changeRootPassword(newPass)
  if len(newPass) > 0:
    _changeAPPassword(newPass)

  if (not os.path.isfile(STATE_DIR + "/password-setup.done")):
    pass_done = open(STATE_DIR + "/password-setup.done", "w")
    pass_done.write("Indicates that password has been changed via oobe.\n")
    pass_done.close()
    print("First-time root password setup complete. Enabling SSH on WiFi interface.")
    subprocess.call("sed -i 's/^BindToDevice=/# BindToDevice=/g' /lib/systemd/system/sshd.socket ; sync ; systemctl daemon-reload; systemctl restart sshd.socket", shell=True)

def _changeRootPassword(newPass):
  echoSub = subprocess.Popen(["echo", "root:" + newPass], stdout=subprocess.PIPE)
  chpasswdSub = subprocess.Popen(["chpasswd"], stdin=echoSub.stdout, stdout=subprocess.PIPE)
  echoSub.stdout.close()  # Allow echoSub to receive a SIGPIPE if chpasswdSub exits.
  chpasswdSub.communicate()[0]

def getNetworkIdentity():
  return input("Please enter the network username: ")

def getNetworkPassword():
  pw = ''
  while len(pw) == 0:
    pw = getPassword("What is the network password?: ")
  return pw

def reset(stage):
  subprocess.call("clear", shell=True)
  print(text_colors.CYAN + "\nConfigure Edison: " + stage + "\n" + text_colors.END)


# Main Functions
#######################################

def setEdisonHostname():
  while 1:
    name = input("Give this Edison a unique name.\nThis will be used for the access point SSID and mDNS address.\nMake it at least five characters long (leave empty to skip): ")
    if (WSREGEX.search(name)):
      print("")
      print('Hostname must not contain whitespaces. Please try again.')
      print("")
    elif (len(name) == 0):
      print("Skipping name change...")
      break
    elif (len(name) > 4):
      if verified(name):
        print("")
        break
      else:
        print("")
    else:
      print("")
      print('\"' + name + '\" is too short. Please try again.')
      print("")

  if len(name) > 0:
      changeName(name)

def setEdisonPassword():
   while 1:
     password = getPassword("Enter a new password (leave empty to abort)\nThis will be used to connect to the access point and login to the device.\nPassword: \t")
     if (password == getPassword("Please enter the password again: \t")):
         if (WSREGEX.search(password)):
             print("")
             print('The device password must not contain whitespaces. Please try again.')
             print("")
         elif len(password) == 0:
             print("Skipping password change.")
             return
         elif len(password) < 8 or len(password) > 63:
             print("")
             print("The device password must be between 8 and 63 characters long. Please try again.")
             print("")
         else:
             break
     else:
       print("")
       print("The passwords do not match. Please try again.")
       print("")

   changePassword(password)
   print("The device password has been changed.\n")

def decideToConnect():
  while 1:
    verify = input("Do you want to set up wifi? " + text_colors.YELLOW + "[Y or N]" + text_colors.END + ": ")
    if verify == "y" or verify == "Y":
      return 1
    elif verify == "n" or verify == "N":
      return 0
    else:
      print("I need Y or N as a reply.")

def _getCachedService(service):
    global _cachedServices
    
    for i in _cachedServices:
        if i[2] == service:
            return i[1]

def _getServices(type):
    data = subprocess.getoutput("connmanctl services | grep " + type)
    data = data.split("\n")

    network_map = {}
    ssid_keys = []
    connection = []
    for i in range(len(data)):
        (left, seperator, session) = data[i].rpartition(' ')
        ssid = left[4:].rstrip()
        flags = left[:4].rstrip()
        if ssid != "":
            connection.append((flags, ssid, session))
    return connection

def _scanForNetworks():
    global lastScanned
    global _cachedServices
    connection = []
    now = datetime.datetime.now()
    if((now - lastScanned) >  timedelta(minutes = 2)):
        lastScanned = now
        data = subprocess.check_output("connmanctl scan wifi", shell=True)
        connection.append(("", "Scanning, please wait 10 seconds", ""))
    else:
        connection = _getServices("wifi")
        _cachedServices = connection
    return connection

def _store(WiFi_Network, WiFi_Name, WiFi_Passphrase):
    ConnmanServices = configparser.ConfigParser()
    ConnmanServices.optionxform=str
    ConnmanServices.read(CONNMAN_SERVICES)
    service = WiFi_Network
    service.replace(" ", "")
    print(service)
    if ConnmanServices.get("service_" + service, "Name", fallback="") == "":
        ConnmanServices["service_" + service] = {}
    if WiFi_Passphrase != "!@#$%^&*":
        ConnmanServices["service_" + service]["Type"] = "wifi"
        ConnmanServices["service_" + service]["Name"] = WiFi_Name
        ConnmanServices["service_" + service]["Passphrase"] = WiFi_Passphrase
        with open(CONNMAN_SERVICES, 'w') as configfile:
            ConnmanServices.write(configfile)

def scanForNetworks():
    stdout.write("Starting scan\r")
    stdout.flush()

    return _scanForNetworks()

def _selectNetwork(service):
    data = subprocess.check_output("connmanctl connect " + service, shell=True)
    print(data)

def selectNetwork(ssid_keys):
  i = 2
  print("0 :\tRescan for networks")
  print("1 :\tExit WiFi Setup")
  print("2 :\tManually input a hidden SSID")
  for ssid in ssid_keys:
    i = i + 1
    print(i, ":\t", ssid)

  print("")
  choice = -1
  while 1:
    try:
      if i == 2:
        choice = int(input("\nEnter 0 to rescan for networks.\nEnter 1 to exit.\nEnter 2 to input a hidden network SSID: "))
      elif i == 3:
        choice = int(input("\nEnter 0 to rescan for networks.\nEnter 1 to exit.\nEnter 2 to input a hidden network SSID.\nEnter 3 to choose %s: " % ssid_keys[0]))
      else:
        choice = int(input("\nEnter 0 to rescan for networks.\nEnter 1 to exit.\nEnter 2 to input a hidden network SSID.\nEnter a number between 3 to %s to choose one of the listed network SSIDs: " % i))
    except TypeError:
      choice = -1
    except ValueError:
      choice = -1

    if choice == 0:
      break
    elif choice == 1:
      sys.exit(0)
    elif choice == 2:
      break
    elif choice > 2 and choice <= i and verified(ssid_keys[choice-3]):
      break
  return choice

def configureHiddenNetwork(ssid):
  print('''
    0: OPEN
    1: WEP
    2: WPA-Personal(PSK)
    3: WPA-Enterprise (EAP)
  ''')
  while 1:
    try:
      security = int(input("Select the type of security [0 to 3]: "))
    except TypeError:
      security = -1
    except ValueError:
      security = -1

    if security == 0:
      return wpa_templates.OPEN % (ssid, "scan_ssid=1")
    elif security == 1:
      password = ''
      while len(password) != 5 and len(password) != 13:
        print("Password must be either 5 or 13 characters.")
        password = getNetworkPassword()
      return wpa_templates.WEP % (ssid, "scan_ssid=1", password)
    elif security == 2:
      password = ''
      while len(password) < 8 or len(password) > 63:
        print("Password must be between 8 and 63 characters.")
        password = getNetworkPassword()
      return wpa_templates.WPAPSK % (ssid, "scan_ssid=1", password)
    elif security == 3:
      identity = getNetworkIdentity()
      password = getNetworkPassword()
      return wpa_templates.WPAEAP % (ssid, "scan_ssid=1", identity, password)
    else:
      print("Invalid input.")
  return network_template_open % ssid

def configureNetwork(choice,ssid_keys,network_map):
  ssid = ssid_keys[choice-3]
  if network_map[ssid] == "OPEN":
    return wpa_templates.OPEN % (ssid, "")
  elif network_map[ssid] == "WEP":
    password = ''
    while len(password) != 5 and len(password) != 13:
        print("Password must be either 5 or 13 characters.")
        password = getNetworkPassword()
    return wpa_templates.WEP % (ssid, "", password)
  elif network_map[ssid] == "WPA-PSK":
    password = ''
    while len(password) < 8 or len(password) > 63:
        print("Password must be between 8 and 63 characters.")
        password = getNetworkPassword()
    return wpa_templates.WPAPSK % (ssid, "", password)
  elif network_map[ssid] == "WPA-EAP":
    identity = getNetworkIdentity()
    password = getNetworkPassword()
    return wpa_templates.WPAEAP % (ssid, "", identity, password)
  else:
    print(noooo("the last line of startNetworkConfig"))

def configureNetworkAP(changewifi):
  protocol = changewifi[0]
  ssid = changewifi[1]
  if protocol == "OPEN":
    return wpa_templates.OPEN % (ssid, "scan_ssid=1")
  elif protocol == "WEP":
    password = changewifi[2]
    if len(password) != 5 and len(password) != 13:
        print("Password must be either 5 or 13 characters.")
        return None
    return wpa_templates.WEP % (ssid, "scan_ssid=1", password)
  elif protocol == "WPA-PSK":
    password = changewifi[2]
    if len(password) < 8 or len(password) > 63:
        print("Password must be between 8 and 63 characters.")
        return None
    return wpa_templates.WPAPSK % (ssid, "scan_ssid=1", password)
  elif protocol == "WPA-EAP":
    if len(changewifi) != 4:
      print("Both Identify and Password must be provided. Unable to proceed")
      return
    identity = changewifi[2]
    password = changewifi[3]
    return wpa_templates.WPAEAP % (ssid, "scan_ssid=1", identity, password)
  else:
    print(noooo("the last line of startNetworkConfig"))

def setNetwork(network_conf, ssid):
    if not os.path.isfile('/etc/wpa_supplicant/wpa_supplicant.conf.original'):
        subprocess.call("cp /etc/wpa_supplicant/wpa_supplicant.conf /etc/wpa_supplicant/wpa_supplicant.conf.original", shell=True)

    wpa_supplicant = open('/etc/wpa_supplicant/wpa_supplicant.conf','a') #Will not take care of duplicates at the moment.
    wpa_supplicant.write(network_conf)
    wpa_supplicant.close();

    print("Initiating connection to " + ssid + ". Please wait...")

    try:
        if int(subprocess.check_output("systemctl status wpa_supplicant | grep 'active (running)' | wc -l", shell=True)) == 0:
          subprocess.call("systemctl stop hostapd &> /dev/null", shell=True)
          subprocess.call("systemctl start wpa_supplicant &> /dev/null", shell=True)
          time.sleep(10)
        else:
          subprocess.call("wpa_cli reconfigure &> /dev/null && sleep 2", shell=True)

        network_count = int(subprocess.check_output('wpa_cli list_networks | wc -l', shell=True))
        subprocess.call("wpa_cli select_network " + str(network_count - 2 - 1) + " &> /dev/null", shell=True)
        time.sleep(5)

        ifarray = subprocess.check_output("wpa_cli ifname", shell=True).split()
        subprocess.call("udhcpc -i " + ifarray[len(ifarray)-1] + " -n &> /dev/null", shell=True)
    except Exception as e:
        print(e)
        print("Sorry. Could not get an IP address.")
    else:
        print("Attempting to enable network access, please check 'wpa_cli status' after a minute to confirm.")

def checkNetwork():
  i = 60
  while 1:
    waiting = "Connecting: %s seconds left         \r" % i
    stdout.write(waiting)
    stdout.flush()
    time.sleep(1)
    address = os.popen("ifconfig | grep -A1 'wlan0' | grep 'inet'| awk -F' ' '{ print $2 }' | awk -F':' '{ print $2 }'").read().rstrip()
    if not address == "":
      print("Done. Please connect your laptop or PC to the same network as this device and go to " + \
        text_colors.CYAN + "http://" + address + text_colors.END + " or " + text_colors.CYAN + \
        "http://" + subprocess.check_output('hostname').strip() + ".local" + text_colors.END + \
        " in your browser.")
      break
    if i == 0:
      print("Not connected. Something went wrong.")
      break
    i = i-1

def connectNetwork():
  network_conf = ""
  ssid = ""

  while 1:
    reset("WiFi Connection")
    connections = scanForNetworks()
    choice = selectNetwork(ssid_keys)

    #choice is validated within selectNetwork.
    if choice == 2:
      while 1:
          ssid = input("Please enter the hidden network SSID: ")
          if verified(ssid):
              break
      network_conf = configureHiddenNetwork(ssid)
      break
    elif choice:
      network_conf = configureNetwork(choice, ssid_keys,network_map)
      ssid = ssid_keys[choice-3]
      break

  #print network_conf
  setNetwork(network_conf, ssid)
  checkNetwork()
  disableOneTimeSetup(True)

def _getIFaceIP(iface):
    ipstr = ''
    try:
        ipstr = subprocess.check_output("ifconfig " + iface + " | grep \'inet addr:\'", shell=True)
    except subprocess.CalledProcessError:
        return "none"
    except Exception as inst:
        return "none"

    ipstr = str(ipstr, 'utf-8')
    startIdx = ipstr.find('inet addr:')
    if (startIdx == -1):
         return "none"
    ipstr = ipstr[ipstr.find('inet addr:')+10:].split()[0]
    return ipstr

def showWiFiIP():
    ipstr = _getIFaceIP('wlan0')
    if ipstr == 'none':
        print("No IP address found. Device not connected?")
    return ipstr

def showWiFiMode():
    Mode = _getWiFiMode()
    if Mode == 'Err':
        print("Connman error")
    return Mode

def getCurrentFirmwareInfo():
    f = open('/etc/version','r')
    ver_str = f.readline()
    f.close()
    return ("edison-" + ver_str.split('-')[0], ver_str.split('-')[1].splitlines()[0])

def isRestartWithAPSet():
    try:
        ret_value = subprocess.call("mkdir -p /update", shell=True)
        if ret_value != 0:
            print("Could not create destination folder.")
            return False
    except Exception as inst:
        print("Could not create destination folder.")
        print(type(inst), file=sys.stderr)
        print(inst, file=sys.stderr)
        return False

    try:
        ret_value = subprocess.call("losetup -o 8192 /dev/loop0 /dev/disk/by-partlabel/update", shell=True)
        if ret_value != 0:
            print("Could not setup loop device")
            return False
    except Exception as inst:
        print("Could not setup loop device")
        print(type(inst), file=sys.stderr)
        print(inst, file=sys.stderr)
        return False

    try:
        ret_value = subprocess.call("mount /dev/loop0 /update", shell=True)
        if ret_value != 0:
            print("Could not perform mount operation.")
            return False
    except Exception as inst:
        print("Could not perform mount operation.")
        print(type(inst), file=sys.stderr)
        print(inst, file=sys.stderr)
        return False

    if os.path.isfile("/update" + HOST_AP_MODE_FILE):
        ap_mode = True
    else:
        ap_mode = False
    try:
        ret_value = subprocess.call("umount /update", shell=True)
        if ret_value != 0:
            print("Could not perform umount operation.")
            return False
    except Exception as inst:
        print("Could not perform umount operation.")
        print(type(inst), file=sys.stderr)
        print(inst, file=sys.stderr)
        return False
    try:
        ret_value = subprocess.call("rmdir /update", shell=True)
        if ret_value != 0:
            print("Could not delete destination folder.")
            return False
    except Exception as inst:
        print("Could not delete destination folder.")
        print(type(inst), file=sys.stderr)
        print(inst, file=sys.stderr)
        return False

    return ap_mode

def full():
  reset("Device Password")
  setEdisonPassword()
  reset("Device Name")
  setEdisonHostname()
  if decideToConnect():
    connectNetwork()
  else:
    print("Done.\n")

def getSSID():
    return _getAPSSID()

def enableOneTimeSetup(persist):
    subprocess.call("systemctl restart blink-led", shell=True)

    hostname = subprocess.check_output('hostname').strip()

    print("Scanning and saving WiFi networks...")
    scanForNetworks()

    subprocess.call("systemctl stop wpa_supplicant", shell=True)

    print("Restarting WiFi access point. Please wait...")
    print("")

    if persist:
        subprocess.call("systemctl disable wpa_supplicant &> /dev/null", shell=True)
        subprocess.call("systemctl enable hostapd &> /dev/null", shell=True)
        subprocess.call("systemctl enable blink-led &> /dev/null", shell=True)

    if int(subprocess.check_output("systemctl status hostapd | grep 'active (running)' | wc -l", shell=True)) == 0:
        subprocess.call("systemctl start hostapd &> /dev/null", shell=True)

    myssid = getSSID()

    print("From your PC or laptop, connect to the", "'" + myssid + "' network ")
    print("and visit",  "'" + hostname + ".local' in the browser")

def disableOneTimeSetup(persist):
    subprocess.call("systemctl stop blink-led &> /dev/null", shell=True)
    subprocess.call("systemctl stop hostapd &> /dev/null", shell=True)

    try:
        os.remove(STATE_DIR + "/networks.txt")
    except Exception as inst:
        pass

    if persist:
        subprocess.call("systemctl enable wpa_supplicant &> /dev/null", shell=True)
        subprocess.call("systemctl disable hostapd &> /dev/null", shell=True)
        subprocess.call("systemctl disable blink-led &> /dev/null", shell=True)

    if int(subprocess.check_output("systemctl status wpa_supplicant | grep 'active (running)' | wc -l", shell=True)) == 0:
        subprocess.call("systemctl start wpa_supplicant &> /dev/null", shell=True)

def toggleOneTimeSetup(persist):
    if showWiFiMode() == "Master":
        disableOneTimeSetup(persist)
    else:
        enableOneTimeSetup(persist)

def getHostName():
    return(str(subprocess.check_output('hostname', shell=True).strip(), 'utf-8'))

def showNames():
    hostname = getHostName()
    ssid = getSSID()
    default_ssid = _getDefaultSSID()
    print('{"hostname": "' + hostname + '", "ssid": "' + ssid + '", "default_ssid": "' + default_ssid + '"}')

@route('/')
def main_form():
    print(request['REMOTE_ADDR'])
    return template('index' )

@route('/', method='POST')
def do_main_form():
    control = request.forms.get('button')
    print(control)
    redirect('/')

@route('/activate')
def activate():
    return template('activate', hostname = "hostname")

@route('/name')
def name_form():
    global Settings
    if Settings.HostName.Changed == 0:
        Settings.HostName.Old = hostname = getHostName()
        tooltip = "Names consist of 'a-z', '0-9', '-'"
        checked = ""
    else:
        hostname = Settings.HostName.New
        tooltip = Settings.HostName.Tooltip
        if Settings.HostName.Valid == 1:
            checked = "font-weight: bold; "
        else:
            checked = "border:3px; border-style:solid; border-color:red; padding: 1em; "

    return template('name', hostname_checked = checked, hostname_tooltip = tooltip, hostname = hostname)

@route('/name', method='POST')
def do_name_form():
    global Settings
    currentname = getHostName()
    hostname = request.forms.get('hostname')
    Settings.HostName.Changed = 0
    if hostname != currentname:
 #       _changeHostName(hostname)
        Settings.HostName.New = hostname
        Settings.HostName.Changed = 1
        Settings.HostName.Valid = 0
        check = _checkName(hostname)
        if check == 0:
            Settings.HostName.Valid = 1
            Settings.HostName.Tooltip = "Valid host name"
        elif check == -1:
            Settings.HostName.Tooltip = "Incorrect length"
        elif check == -2:
            Settings.HostName.Tooltip = "Can not start or end with '-'"
        elif check == -3:
            Settings.HostName.Tooltip = "Can not contain other then 'a-z', '0-9', '-'"
    redirect('/name')

@route('/wired')
def wired_form():
    global Settings
    Host_IP = request['REMOTE_ADDR']
    if Settings.Wired.Changed == 0:
        Net = _getGadgetMode()
        if Net == "None":
            Net = _getWiredMode()
            if Net == "None":
                Settings.Wired.Type = "No ethernet available"
                Settings.Wired.IP = ""
                Settings.Wired.Mode = "OFF"
            if Net == "Powered":
                Settings.Wired.IP = "Not connected"
                Settings.Wired.Type = "Ethernet dongle"
                Settings.Wired.Mode = "Checked"
            if Net == "Connected":
                Settings.Wired.IP = _getIFaceIP("eth0")
                Settings.Wired.Type = "Ethernet dongle"
                Settings.Wired.Mode = "Checked"
            else:
                Settings.Wired.Type = "An error has occured"
                Settings.Wired.IP = ""
                Settings.Wired.Mode = "OFF"
        elif Net == "Powered":
            Settings.Wired.IP = "Not connected"
            Settings.Wired.Type = "Ethernet over USB (OTG)"
            Settings.Wired.Mode = "Checked"
        elif Net == "Connected":
            Settings.Wired.IP = _getIFaceIP("usb0")
            Settings.Wired.Type = "Ethernet over USB (OTG)"
            Settings.Wired.Mode = "Checked"
        elif Net == "Off":
            Settings.Wired.Type = "Ethernet over USB (OTG)"
            Settings.Wired.IP = "Not powered"
            Settings.Wired.Mode = "OFF"
        else:
            Settings.Wired.Type = "An error has occured"
            Settings.Wired.IP = ""
            Settings.Wired.Mode = "OFF"
    connections = _getServices("Wired")
    if connections:
        ConnState = connections[0][0]
    else:
        ConnState = ""
    Wired_State = ""

    if Net == "Connected":
        if "O" in ConnState:
            Wired_State = "Primary connection verified On Line"
        elif "R" in ConnState:
            Wired_State = "Fall back connection standby"
    if Net == "Powered":
        if "*" in ConnState:
            Wired_State = "Connection available"
        else:
            Wired_State = "Not plugged"
    return template('wired', Wired_Type = Settings.Wired.Type, Wired_IP = Settings.Wired.IP, \
        Wired_Mode = Settings.Wired.Mode, Wired_State = Wired_State, Host_IP = Host_IP)

@route('/wired', method='POST')
def do_wired_form():
    global Settings
    Settings.Wired.NewMode = request.forms.get('Wired_Mode')
    if Settings.Wired.NewMode != Settings.Wired.Mode:
        Settings.Wired.Changed = 1
        
@route('/bt')
def bt_form():
    global Settings
    Host_IP = request['REMOTE_ADDR']
    if Settings.Wired.Changed == 0:
        Net = _getBTMode()
        if Net == "None":
            Settings.BT.Type = "No bluetooth available"
            Settings.BT.IP = ""
            Settings.BT.Mode = "OFF"
        if Net == "Powered":
            Settings.BT.IP = "Not connected"
            Settings.BT.Type = ""
            Settings.BT.Mode = "Checked"
        if Net == "Connected":
            Settings.BT.IP = _getIFaceIP("bnep0")
            Settings.BT.Type = "Ethernet dongle"
            Settings.BT.Mode = "Checked"
    else:
        Settings.Wired.Type = "An error has occured"
        Settings.Wired.IP = ""
        Settings.Wired.Mode = "OFF"
            
    connections = _getServices("bluetooth")
    if connections:
        ConnState = connections[0][0]
    else:
        ConnState = ""
    Wired_State = ""

    if Net == "Connected":
        if "O" in ConnState:
            Wired_State = "Primary connection verified On Line"
        elif "R" in ConnState:
            Wired_State = "Fall back connection standby"
    if Net == "Powered":
        if "*" in ConnState:
            Wired_State = "Connection available"
        else:
            Wired_State = "Not plugged"
    return template('wired', Wired_Type = Settings.BT.Type, Wired_IP = Settings.BT.IP, \
        Wired_Mode = Settings.BT.Mode, Wired_State = Wired_State, Host_IP = Host_IP)

@route('/wireless')
@route('/wirelessr')
def wireless_form():
    Host_IP = request['REMOTE_ADDR']
    WiFi_mode = ""
    WiFi_IP = "WiFi is currently not powered"
    WiFiMode = _getWiFiMode()
    WiFi_State = ""
    ReloadMode = False

    if WiFiMode == "AP":
        _setWiFiMode("Powered")
    elif WiFiMode == "Connected":
        WiFi_mode = "Checked"
        WiFi_IP = _getIFaceIP("wlan0")
    elif WiFiMode == "Powered":
        WiFi_IP = "WiFi is powered but inactive"
    else:
        _setWiFiMode("Powered")

    connections = _scanForNetworks()
    print(connections)
    if connections[0][1] == "Scanning, please wait 10 seconds":
        WiFi_State = "Scanning"
        ReloadMode = True
    else:
        if WiFiMode == "Connected":
            ConnState = connections[0][0]
            if "O" in ConnState:
                WiFi_State = "Primary connection verified On Line"
            elif "R" in ConnState:
                WiFi_State = "Fall back connection standby"
        if WiFiMode != _getWiFiMode():
            _setWiFiMode(WiFiMode)
    if ReloadMode == True:
        return template('wirelessr',  
                    WiFi_mode = WiFi_mode, rows = connections, WiFi_IP = WiFi_IP, WiFi_Passphrase = "!@#$%^&*", WiFi_State = WiFi_State, Host_IP = Host_IP)
    else:
        return template('wireless',  
                    WiFi_mode = WiFi_mode, rows = connections, WiFi_IP = WiFi_IP, WiFi_Passphrase = "!@#$%^&*", WiFi_State = WiFi_State, Host_IP = Host_IP)

@route('/wireless', method='POST')
def do_wireless_form():
    WiFiMode = _getWiFiMode()
    WiFi_mode = request.forms.get('WiFi_mode')
    WiFi_Network = request.forms.get('newwifis')
    WiFi_Passphrase = request.forms.get('WiFipassphrase')
    if WiFi_mode == "on":
        new_WiFiMode = "Connected"
    else:
        new_WiFiMode = "Off"
    if WiFiMode != new_WiFiMode:
        if new_WiFiMode == "Connected":
            _setWiFiMode("Powered")
        else:
            _setWiFiMode(new_WiFiMode)
    WiFiMode = _getWiFiMode()
    if WiFiMode == "Powered" or WiFiMode == "Connected":
        WiFi_Name = _getCachedService(WiFi_Network)
        _store(WiFi_Network, WiFi_Name, WiFi_Passphrase)
        _selectNetwork(WiFi_Network)
    redirect('/wireless')


@route('/ap')
def ap_form():
    AP_mode = ""
    AP_IP = "Access Point is currently OFF"
    WiFi_mode = ""
    WiFi_IP = "WiFi is currently not powered"
    AP_name = _getAPSSID()
    WiFiMode = _getWiFiMode()
    WiFi_State = ""
    hostname = getHostName()

    if WiFiMode == "AP":
        AP_mode = "checked"
        AP_IP = "Acces Point " + AP_name + " is currently on IP address: " + _getIFaceIP("tether")
        _setWiFiMode("Powered")
    elif WiFiMode == "Connected":
        WiFi_mode = "Checked"
    elif WiFiMode == "Powered":
        WiFi_IP = "WiFi is powered but inactive"
    else:
        _setWiFiMode("Powered")
    return template('ap', hostname = hostname, WiFi_mode = WiFi_mode, AP_mode = AP_mode, AP_name = AP_name, AP_passphrase = "        ", AP_IP = AP_IP)

@route('/main.css')
def server_static(filename):
    return static_file('main.css', root='.')

@route('/img/<filename:re:.*\.png>')
def send_image(filename):
    return static_file(filename, root='img', mimetype='image/png')

@route('/img/<filename:re:.*\.svg>')
def send_image(filename):
    return static_file(filename, root='img', mimetype='image/svg+xml')

@route('/css/<filename:re:.*\.css>')
def send_static(filename):
    return static_file(filename, root='css')

@route('/script/<filename:re:.*\.js>')
def send_static(filename):
    return static_file(filename, root='script')

@route('/<filename:re:favicon.ico>')
def send_image(filename):
    return static_file(filename, root='img', mimetype='image/x-icon')

def main():
    global lastScanned
    global Settings 
    Settings = classSettings()
    global CURR_PACKAGE_PATH

    parser = argparse.ArgumentParser(prog='configure_edison')

    parser.add_argument('--restartWithAP', dest='restartwithap', help=argparse.SUPPRESS, action='store_true', default=False)
    parser.add_argument('--persist', dest='persist', help=argparse.SUPPRESS, action='store_true', default=False)

    root_group = parser.add_mutually_exclusive_group()

    group_interactive = root_group.add_mutually_exclusive_group()
    group_interactive.add_argument('--setup', dest='setup', help='Goes through changing the device name, password, and wifi options', action='store_true', default=False)
    group_interactive.add_argument('--name', dest='name', help='Changes the device name', action='store_true', default=False)
    group_interactive.add_argument('--password', dest='password', help='Changes the device password', action='store_true', default=False)
    group_interactive.add_argument('--wifi', dest='wifi', help='Changes the wifi options', action='store_true', default=False)

    group_non_interactive = root_group.add_mutually_exclusive_group()
    group_non_interactive.add_argument('--isRestartWithAPSet', dest='isrestartwithapset', help=argparse.SUPPRESS, action='store_true', default=False)
    group_non_interactive.add_argument('--showWiFiIP', dest='showwifiip', help='IP address associated with the wireless interface', action='store_true', default=False)
    group_non_interactive.add_argument('--showWiFiMode', dest='showwifimode', help='Show current mode for the wireless interface', action='store_true', default=False)
    group_non_interactive.add_argument('--disableOneTimeSetup', dest='disableonetimesetup', help='Disable one-time setup with WiFi access point and enable WiFi client mode \
                                       Append --persist to retain this setting after reboot', action='store_true', default=False)
    group_non_interactive.add_argument('--enableOneTimeSetup', dest='enableonetimesetup', help='Enable one-time setup with WiFi access point and disable WiFi client mode. \
                                        Append --persist to retain this setting after reboot', action='store_true', default=False)
    group_non_interactive.add_argument('--toggleOneTimeSetup', dest='toggleonetimesetup', help='Switch between one-time setup with WiFi access point and WiFi client mode, and visa-versa. \
                                       Append --persist to retain this setting after reboot', action='store_true', default=False)
    group_non_interactive.add_argument('--changePassword', metavar='password', dest='changepassword', const='', help=argparse.SUPPRESS, nargs='?')
    group_non_interactive.add_argument('--changeName', metavar='name', dest='changename', help=argparse.SUPPRESS, nargs=1)
    group_non_interactive.add_argument('--changeWiFi', metavar='securityType SSID [Identity | password]', dest='changewifi', help=argparse.SUPPRESS, nargs='+')
    group_non_interactive.add_argument('--showNames', dest='shownames', help='Show device name and SSID', action='store_true', default=False)
    group_non_interactive.add_argument('--webInterface', dest='webInterface', help='Start a web server', action='store_true', default=False)

    if len(sys.argv)==1:
        parser.print_help()
        sys.exit(1)

    args = parser.parse_args()

    if args.name:
        reset("Device Name")
        setEdisonHostname()

    if args.password:
        reset("Device Password")
        setEdisonPassword()

    if args.wifi:
        connectNetwork()
        if not os.path.isfile(STATE_DIR + "/password-setup.done"):
            print("Warning: SSH is not yet enabled on the wireless interface. To enable SSH access to this device via wireless run configure_edison --password first.")

    if args.setup:
        full()

    if args.shownames:
        showNames()

    if args.isrestartwithapset:
        print(isRestartWithAPSet())

    if args.changepassword != None:
        changePassword(args.changepassword)

    if args.changename != None:
        changeName(args.changename[0])

    if args.showwifiip:
        print(showWiFiIP())

    if args.showwifimode:
        print(showWiFiMode())

    if args.enableonetimesetup:
        enableOneTimeSetup(args.persist)

    if args.disableonetimesetup:
        disableOneTimeSetup(args.persist)

    if args.toggleonetimesetup:
        toggleOneTimeSetup(args.persist)

    if args.changewifi != None:
        network_conf = configureNetworkAP(args.changewifi)
        if network_conf != None:
            setNetwork(network_conf, args.changewifi[1])

    if args.webInterface:
        lastScanned = datetime.datetime.now() - timedelta(minutes = 2)
        print(lastScanned)
        os.chdir(os.path.dirname('/usr/lib/edison_config_tools/public/'))
        debug(False)
        run(host='0.0.0.0', port=80)

    #print 'restartwithap = ',args.restartwithap
    #print 'persist = ',args.persist
    #print 'setup = ',args.setup
    #print 'name = ',args.name
    #print 'password = ',args.password
    #print 'wifi = ',args.wifi

    #print 'showwifiip = ',args.showwifiip
    #print 'disableonetimesetup = ',args.disableonetimesetup
    #print 'enableonetimesetup = ',args.enableonetimesetup
    #print 'changepassword = ',args.changepassword

    #print 'changename = ',args.changename

if __name__ == "__main__":
      main()
